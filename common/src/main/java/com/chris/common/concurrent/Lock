在多线程编程里面一个重要的概念是锁定，如果一个资源是多个线程共享的，为了保证数据的完整性，在进行事务性操作时需要将共享资源锁定，这样可以保证在做事务性操作时只有一个线程能对资源进行操作，从而保证数据的完整性。在5.0以前，锁定的功能是由Synchronized关键字来实现的，这样做存在几个问题：

每次只能对一个对象进行锁定。若需要锁定多个对象，编程就比较麻烦，一不小心就会出现死锁现象。如果线程因拿不到锁定而进入等待状况，是没有办法将其打断的,在Java 5.0里出现两种锁的工具可供使用，下图是这两个工具的接口及其实现：



Lock接口

ReentrantLock是Lock的具体类，Lock提供了以下一些方法：

lock(): 请求锁定，如果锁已被别的线程锁定，调用此方法的线程被阻断进入等待状态。tryLock()：如果锁没被别的线程锁定，进入锁定状态，并返回true。若锁已被锁定，返回false，不进入等待状态。此方法还可带时间参数，如果锁在方法执行时已被锁定，线程将继续等待规定的时间，若还不行才返回false。unlock()：取消锁定，需要注意的是Lock不会自动取消，编程时必须手动解锁。
代码：

//生成一个锁

Lock lock = new ReentrantLock();

public void accessProtectedResource() {

      lock.lock(); //取得锁定

      try {

           //对共享资源进行操作

      } finally {

      //一定记着把锁取消掉，锁本身是不会自动解锁的

          lock.unlock();

      }

}

ReadWriteLock接口

为了提高效率有些共享资源允许同时进行多个读的操作，但只允许一个写的操作，比如一个文件，只要其内容不变可以让多个线程同时读，不必做排他的锁定，排他的锁定只有在写的时候需要，以保证别的线程不会看到数据不完整的文件。ReadWriteLock可满足这种需要。ReadWriteLock内置两个Lock，一个是读的Lock，一个是写的Lock。多个线程可同时得到读的Lock，但只有一个线程能得到写的Lock，而且写的Lock被锁定后，任何线程都不能得到Lock。ReadWriteLock提供的方法有：

readLock(): 返回一个读的lockwriteLock(): 返回一个写的lock, 此lock是排他的。